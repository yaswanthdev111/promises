<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <!-- 
    Promises: are used to handle the async operations after callbacks.
        --we choose promises then callbacks to oercome the callbackhell issue.
        -- This lets asynchronous methods return values like synchronous methods.
    A Promise is in one of these states:
    1. pending: initial state, neither fulfilled nor rejected.
    2.fulfilled: meaning that the operation was completed successfully.
    3.rejected: meaning that the operation failed.

    --Promise is a object.
    --if promise is success or resolved then it captured by . then() block.
    --if promise is failure or rejected then it captured by . catch() block.
    finally():it executes whether the promise is resolved or rejected and it won't contain any argument.

    Creating a promise
    1.const x=new Promise((resolve,reject)=>{});
    2.function promise(){
        const x=new Promise((resolve,reject)=>{});
        return x;
    }
    3.function promise(){
        return new Promise((resolve,reject)=>{});
    
    }

    By creating multiple promises we get a promise chaining or method chaining issue.
    -->
    <script>
      /*Task 1*/
      function promise1(){
        let pr1=new Promise((resolve,reject)=>{
          let a=1
          setTimeout(() => {
            if(a==1){
              resolve("promise 1 is resolved");
              a++;
            }
            else
            reject("promise1 is rejected");
            
          }, 1000);
        })
        return pr1
      }
      promise1().then((e)=>{console.log(e)}).catch((e)=>{console.log(e)})
      /*Task 2*/
      function promise2(){
        return new Promise((res,rej)=>{
          let a=1
          setTimeout(() => {
            if(a!=1)
            res("promise2 is resolved");
          else
          rej("promise2 is rejected")
          }, 1500);
        })
      }
      promise2().then((e)=>{console.log(e)}).catch((e)=>{console.log(e)})
      /*Task 3*/
      const x = new Promise((resolve, reject) => {
        setTimeout(() => {
          if (true) resolve("promise1 is fullfilled");
          else reject("promise1 is rejected");
        }, 10000);
      });
      const y = new Promise((resolve, reject) => {
        setTimeout(() => {
          if (!true) resolve("promise2 is fullfilled");
          else reject("promise2 is rejected");
        }, 5000);
      });
      const z = new Promise((resolve, reject) => {
        setTimeout(() => {
          if (true) resolve("promise3 is fullfilled");
          else reject("promise3 is rejected");
        }, 1000);
      });
            x.then((e) => {
        console.log(e);
        return y;
      })
       .then((e) => {
          console.log(e);
          return z;
        })
        .then((e) => {
          console.log(e);
        })
        .catch((e) => {
          console.log(e);
        })
        .finally(() => {
          console.log("execution is completed");
        });
    </script>
  </body>
</html>
